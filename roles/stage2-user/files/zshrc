#!/bin/zsh

#
# Aliases
#

# Color basic commands.
alias ls='ls --color=auto'
alias grep='grep --color=auto'

# ls helpers
alias ll='ls -l'
alias la='ls -la'

# Short git helpers.
alias gd='git diff'
alias gs='git status'
alias gc='git commit'
alias gca='git commit -a'
alias cola='git-cola &'
alias gg='gitg &'

# Run ansible and reload ZSH.
alias reconfigure-ssh='reconfigure -t ssh'
alias reconfigure-zshrc='reconfigure -t zshrc; source ~/.zshrc'

# Bundler/Chef aliases
alias ce='chef exec'
alias cb='chef exec bundle exec'
alias be='bundle exec'

# I always get this wrong...
alias httpie='http'

# Find files with a matching md5sum
function find_similar() {
    find "${2:-$(pwd)}" -type f -exec md5sum '{}' + | grep "^$(md5sum "$1" | awk '{ print $1 }')" | awk '{ print $2 }'
}

#
# ZSH options
#

setopt INTERACTIVE_COMMENTS             # Allow comments in interactive mode.
setopt RM_STAR_WAIT                     # Force the user to wait before 'rm *'.
setopt AUTO_NAME_DIRS                   # Allows 'cd ~borntyping' (see below).

#
# History settings
#

SAVEHIST=10000                          # Lines of history to save to a file
HISTSIZE=10000                          # Lines of history to keep in memory
HISTFILE="$HOME/.zhistory"              # Save history in .cache

setopt APPEND_HISTORY                   # Append to $HISTFILE, not replace
setopt INC_APPEND_HISTORY               # Append to $HISTFILE while running
setopt SHARE_HISTORY                    # Share history between ZSH instances
setopt EXTENDED_HISTORY                 # Record additional information

setopt HIST_IGNORE_DUPS                 # Ignore adjacent reapeated entries
setopt HIST_EXPIRE_DUPS_FIRST           # Remove duplicate entries first
setopt HIST_FIND_NO_DUPS                # Never find duplicates when searching

#
# Named directories
#

export github="$HOME/Development/github.com"
export gitlab="$HOME/Development/gitlab.com"

export borntyping="$HOME/Development/github.com/borntyping"
export sandbox="$HOME/Development/github.com/borntyping-sandbox"

#
# Environment variables
#

export EDITOR="micro"
export GOPATH="$HOME/.go"
export LS_COLORS="rs=0:di=01;33:ln=target:or=41:ex=32"
export NPM_CONFIG_PREFIX="$HOME/.npm"
export PIPENV_MAX_DEPTH=5
export SSH_RUN_SUDO_KEYRING=1
export VIRTUAL_ENV_DISABLE_PROMPT=1
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python

#
# $PATH
#

function add_to_path() {
  if [[ -d $1 ]] && echo $PATH | grep -v $1 >/dev/null; then
    export PATH="$1:$PATH"
  fi
}

add_to_path "${HOME}/.chefdk/gem/ruby/2.1.0/bin"
add_to_path "${HOME}/.gem/ruby/2.5.0/bin"
add_to_path "${HOME}/.go/bin"
add_to_path "${HOME}/.multirust/toolchains/beta/cargo/bin"
add_to_path "${HOME}/.multirust/toolchains/nightly/cargo/bin"
add_to_path "${HOME}/.multirust/toolchains/stable/cargo/bin"
add_to_path "${HOME}/.npm/bin"

add_to_path "${HOME}/.local/bin"
add_to_path "${HOME}/.bin"

#
# Completion rules
#

fpath=("$HOME/.local/share/zsh/functions" $fpath)

autoload -Uz compinit && compinit       # Loads completion modules
setopt AUTO_MENU                        # Show completion menu on tab press
setopt ALWAYS_TO_END                    # Move cursor after completion
setopt COMPLETE_ALIASES                 # Allow autocompletion for aliases
setopt COMPLETE_IN_WORD                 # Allow completion from middle of word
setopt LIST_PACKED                      # Smallest completion menu
setopt AUTO_PARAM_KEYS                  # Intelligent handling of characters
setopt AUTO_PARAM_SLASH                 #   after a completion
setopt AUTO_REMOVE_SLASH                # Remove trailing slash when needed

bindkey '^[[Z' reverse-menu-complete    # Shift-Tab to go back in menus

zstyle ':completion:*' list-colors ''
zstyle ':completion:*:*:*:*:*' menu select
zstyle ':completion::complete:*' use-cache on
zstyle ':completion::complete:*' cache-path "$HOME/.cache/zsh/completion/"
zstyle ':completion:*:*:*:users' ignored-patterns '*'
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'

# Edit current line (Ctrl+e)
autoload edit-command-line
zle -N edit-command-line
bindkey '^e' edit-command-line

#
# Prompt
#

autoload -U vcs_info                    # Version control information
autoload -U colors && colors            # Adds variables for printing colors
setopt PROMPT_SUBST                     # Allow substitution in PROMPT

prompt_status_fg="$fg[magenta]"
prompt_highlight_fg="$fg[magenta]"
prompt_fg="$fg[magenta]"

zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' check-for-staged-changes true
zstyle ':vcs_info:*' stagedstr "%{$fg[green]%}+%{$reset_color%}"
zstyle ':vcs_info:*' unstagedstr "%{$fg[yellow]%}+%{$reset_color%}"
zstyle ':vcs_info:*' formats "%{$prompt_status_fg%}%s:%{$prompt_highlight_fg%}%b%{$reset_color%}%c%u%m "
zstyle ':vcs_info:*' actionformats "%{$prompt_status_fg%}%s:%{$prompt_highlight_fg%}%b%{$reset_color%}%c%u%m|%a "
zstyle ':vcs_info:git*+set-message:*' hooks git-untracked git-remote


function +vi-git-clean(){
    if [[ $(git status --porcelain | wc -c) -eq 0 ]]; then
        backend_misc[clean]+="%{$fg[red]%}CLEAN%{$reset_color%}"
    else
        backend_misc[clean]+="%{$fg[red]%}NOT CLEAN%{$reset_color%}"
    fi
}

# Add a marker to %u for untracked files
function +vi-git-untracked(){
    if git status --porcelain | fgrep '??' &> /dev/null; then
        hook_com[unstaged]+="%{$fg[red]%}+%{$reset_color%}"
    fi
}

# Show +N/-N when a local branch is ahead-of or behind remote HEAD.
function +vi-git-remote() {
    local ahead behind

    ahead=$(git rev-list "${hook_com[branch]}@{upstream}..HEAD" 2>/dev/null | wc -l)
    (( ahead )) && hook_com[misc]+=" %{$fg[green]%}↑${ahead}%{$reset_color%}"

    behind=$(git rev-list "HEAD..${hook_com[branch]}@{upstream}" 2>/dev/null | wc -l)
    (( behind )) && hook_com[misc]+=" %{$fg[red]%}↓${behind}%{$reset_color%}"
}

function desk_info() {
    desk_info_msg=""
    if [[ -n "$DESK_NAME" ]]; then
        desk_info_msg="%{$prompt_status_fg%}desk:%{$prompt_highlight_fg%}$DESK_NAME%{$reset_color%} "
    fi
}

# Display the current virtualenv when active
function virtualenv_info() {
    virtualenv_info_msg=""
    if [ -n "$VIRTUAL_ENV" ]; then
        virtualenv_info_msg="%{$prompt_status_fg%}virtualenv:%{$prompt_highlight_fg%}$(basename "$VIRTUAL_ENV")%{$reset_color%} "
    fi
}

## Display the currently selected knife-block configuration file
#function knife_info() {
#    knife_info_msg=""
#
#    local ENVIRONMENT_FILE ENVIRONMENT COLOUR
#
#    [[ ! -L "$HOME/.chef/knife.rb" ]] && return
#
#    ENVIRONMENT_FILE=$(realpath "$HOME/.chef/knife.rb")
#    ENVIRONMENT=$(basename $ENVIRONMENT_FILE | sed "s/knife-\(.*\).rb/\1/")
#    COLOUR="$fg_bold[green]"
#
#    # When the environment is `none`, skip showing knife information
#    [[ "$ENVIRONMENT" == "none" ]] && return
#
#    # Set colors based on the environment
#    [[ "$ENVIRONMENT" == "production"  ]] && COLOUR="$fg[red]"
#    [[ "$ENVIRONMENT" == "staging"     ]] && COLOUR="$fg[yellow]"
#    [[ "$ENVIRONMENT" == "development" ]] && COLOUR="$fg[green]"
#
#    ENVIRONMENT="%{$COLOUR%}${ENVIRONMENT}%{$reset_color%}"
#    knife_info_msg="%{$fg_bold[green]%}knife:%{$reset_color%}${ENVIRONMENT} "
#}

# Set terminal title and collect information before showing the prompt
function precmd() {
    case $TERM in
        xterm*) print -Pn "\e]2;%~\a";;
    esac
    vcs_info
    desk_info
    virtualenv_info
}

# Set terminal title before executing a command
function preexec() {
    case $TERM in
        xterm*) print -Pn "\e]2;%~ $ $2\a";;
    esac
}

# Assemble the prompt
#
#   $ sam@hostname ~
#   $ ...
#   $ sam@hostname ~/directory git:master desk:example env:virtualenv knife:production
#   $ ...
#
# The %{ and %} characters are used to stop the prompt from counting invisible
# characters when calculating the length
PROMPT="%{$prompt_status_fg%}$ %n@%m %~%{$reset_color%} \
\${vcs_info_msg_0_}\
\${desk_info_msg}\
\${virtualenv_info_msg}\

%{$prompt_fg%}$%{$reset_color%} "

#
# ZSH syntax highlighting plugin.
# https://github.com/zsh-users/zsh-syntax-highlighting
#

source "$HOME/.local/share/zsh/plugins/syntax-highlighting/zsh-syntax-highlighting.zsh"

ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern)
ZSH_HIGHLIGHT_STYLES[comment]='fg=green'
ZSH_HIGHLIGHT_STYLES[unknown-token]='fg=red'
ZSH_HIGHLIGHT_STYLES[globbing]='fg=cyan'
ZSH_HIGHLIGHT_STYLES[single-quoted-argument]='fg=blue'
ZSH_HIGHLIGHT_STYLES[double-quoted-argument]='fg=blue'
ZSH_HIGHLIGHT_STYLES[dollar-double-quoted-argument]='fg=yellow'
ZSH_HIGHLIGHT_STYLES[back-double-quoted-argument]='fg=yellow'
ZSH_HIGHLIGHT_PATTERNS+=('rm -rf *' 'fg=white,bg=red')
ZSH_HIGHLIGHT_PATTERNS+=('rm -r *' 'fg=white,bg=yellow')
ZSH_HIGHLIGHT_PATTERNS+=('knife block use p*' 'fg=white,bg=red')
ZSH_HIGHLIGHT_PATTERNS+=('knife block use s*' 'fg=white,bg=yellow')
ZSH_HIGHLIGHT_PATTERNS+=('knife block use n*' 'fg=white,bg=green')

#
# z - jump around
# https://github.com/rupa/z
#

source "$HOME/.local/share/zsh/plugins/z/z.sh"

#
# direnv - directory specific environment configuration
# https://direnv.net/
#

eval "$(direnv hook zsh)"

#
# Other plugins.
#

function source_if_path { [[ -f $1 ]] && source $1; }
function source_if_variable { [[ -n $1 ]] && source $1; }

# Virtualenvwrapper
# source_if_path "/usr/share/virtualenvwrapper/virtualenvwrapper.sh"

# Local ZSH config
source_if_path "$HOME/.config/zsh/zshrc"

# Tilix VTE patch
source_if_path "/etc/profile.d/vte-2.91.sh"

# Load Desk environment
source_if_variable "$DESK_ENV"
