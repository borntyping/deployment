#!/bin/bash

#
# ZSH options
#

SAVEHIST=10000                      # Lines of history to save to a file.
HISTSIZE=10000                      # Lines of history to keep in memory.
HISTFILE="$HOME/.zhistory"          # Save history.

setopt ALWAYS_TO_END                # Move cursor after completion.
setopt APPEND_HISTORY               # Append to $HISTFILE, not replace.
setopt AUTO_LIST                    # List choices on ambiguous completion.
setopt AUTO_MENU                    # Show completion menu on tab press.
setopt AUTO_NAME_DIRS               # Allows 'cd ~borntyping' (see below).
setopt AUTO_PARAM_KEYS              # Intelligent handling of characters
setopt AUTO_PARAM_SLASH             #   after a completion.
setopt AUTO_REMOVE_SLASH            # Remove trailing slash when needed.
setopt COMPLETE_ALIASES             # Allow autocompletion for aliases.
setopt COMPLETE_ALIASES             # Tab complete aliases.
setopt COMPLETE_IN_WORD             # Allow completion from middle of word
setopt EXTENDED_GLOB                # File modification glob modifiers.
setopt EXTENDED_HISTORY             # Record additional information.
setopt HIST_EXPIRE_DUPS_FIRST       # Remove duplicate entries first.
setopt HIST_FIND_NO_DUPS            # Never find duplicates when searching.
setopt HIST_IGNORE_ALL_DUPS         # Remove old duplicate entries first.
setopt HIST_IGNORE_DUPS             # Ignore adjacent repeated entries.
setopt HIST_IGNORE_SPACE            # Skip if the line starts with space.
setopt HIST_SAVE_NO_DUPS            # Never save duplicate commands.
setopt HIST_VERIFY                  # Don't immediately run history commands.
setopt INC_APPEND_HISTORY           # Append to $HISTFILE while running.
setopt INTERACTIVE_COMMENTS         # Allow comments in interactive mode.
setopt LIST_PACKED                  # Smallest completion menu.
setopt RM_STAR_WAIT                 # Force the user to wait before 'rm *'.
setopt SHARE_HISTORY                # Share history between ZSH instances.
unsetopt FLOW_CONTROL               # Disable start/stop characters.
unsetopt MENU_COMPLETE              # Don't autoselect completions.

#
# Keybindings
#

# Shift-Tab to go back in menus.
bindkey '^[[Z' reverse-menu-complete

# Edit current line (Ctrl+e).
autoload edit-command-line
zle -N edit-command-line
bindkey '^e' edit-command-line

# Ensure Home/End work as expected.
zmodload zsh/terminfo
bindkey "$terminfo[khome]" beginning-of-line
bindkey "$terminfo[kend]" end-of-line

#
# ZSH packages using antigen.
# https://github.com/zsh-users/antigen
#

source "$HOME/.local/share/zsh/antigen.zsh"
antigen bundle zsh-users/zsh-completions
antigen bundle zsh-users/zsh-syntax-highlighting
antigen apply

#
# Completion rules
#

fpath=("$HOME/.local/share/zsh/functions" $fpath)
autoload -Uz compinit
zstyle ':completion::complete:*' cache-path "$HOME/.cache/zsh/completion/"
zstyle ':completion::complete:*' use-cache on
zstyle ':completion:*:*:*:*:*' menu select
zstyle ':completion:*:*:*:users' ignored-patterns '*'
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
compinit -C

#
# ZSH syntax highlighting plugin (loaded by antigen).
# https://github.com/zsh-users/zsh-syntax-highlighting
#

ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
ZSH_HIGHLIGHT_STYLES[comment]='fg=green'
ZSH_HIGHLIGHT_STYLES[unknown-token]='fg=red'
ZSH_HIGHLIGHT_STYLES[globbing]='fg=cyan'
ZSH_HIGHLIGHT_STYLES[single-quoted-argument]='fg=blue'
ZSH_HIGHLIGHT_STYLES[double-quoted-argument]='fg=blue'
ZSH_HIGHLIGHT_STYLES[dollar-double-quoted-argument]='fg=yellow'
ZSH_HIGHLIGHT_STYLES[back-double-quoted-argument]='fg=yellow'

#
# Prompt
#

autoload -U vcs_info                    # Version control information
autoload -U colors && colors            # Adds variables for printing colors
setopt PROMPT_SUBST                     # Allow substitution in PROMPT

prompt_fg="$fg[magenta]"
prompt_highlight_fg="$fg[blue]"

zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' check-for-staged-changes true
zstyle ':vcs_info:*' stagedstr "%{$fg[green]%}+%{$reset_color%}"
zstyle ':vcs_info:*' unstagedstr "%{$fg[yellow]%}+%{$reset_color%}"
zstyle ':vcs_info:*' formats "%{$prompt_fg%}%b%{$reset_color%}%c%u%m "
zstyle ':vcs_info:*' actionformats "%{$prompt_fg%}%b%{$reset_color%}%c%u%m|%a "
zstyle ':vcs_info:git*+set-message:*' hooks git-untracked git-remote

function +vi-git-clean(){
    if [[ $(git status --porcelain | wc -c) -eq 0 ]]; then
        backend_misc[clean]+="%{$fg[red]%}CLEAN%{$reset_color%}"
    else
        backend_misc[clean]+="%{$fg[red]%}NOT CLEAN%{$reset_color%}"
    fi
}

# Add a marker to %u for untracked files
function +vi-git-untracked(){
    if git status --porcelain | fgrep '??' &> /dev/null; then
        hook_com[unstaged]+="%{$fg[red]%}+%{$reset_color%}"
    fi
}

# Show +N/-N when a local branch is ahead-of or behind remote HEAD.
function +vi-git-remote() {
    local ahead behind

    ahead=$(git rev-list "${hook_com[branch]}@{upstream}..HEAD" 2>/dev/null | wc -l)
    (( ahead )) && hook_com[misc]+=" %{$fg[green]%}↑${ahead}%{$reset_color%}"

    behind=$(git rev-list "HEAD..${hook_com[branch]}@{upstream}" 2>/dev/null | wc -l)
    (( behind )) && hook_com[misc]+=" %{$fg[red]%}↓${behind}%{$reset_color%}"
}

# Display the current virtualenv when active
function zsh_python_info() {
    zsh_python_info_msg=""
    if [[ -n "$PIPENV_ACTIVE" ]]; then
        zsh_python_info_msg="%{$prompt_fg%}pipenv%{$reset_color%} "
    elif [[ -n "$VIRTUAL_ENV" ]]; then
        zsh_python_info_msg="%{$prompt_fg%}virtualenv:$(basename "$VIRTUAL_ENV")%{$reset_color%} "
    fi
}

# Display the current kubectl context
function zsh_kubectl_info() {
    zsh_kubectl_info_msg=""

    local CONTEXT COLOUR
    COLOUR="$prompt_fg"
    CONTEXT="$(kubectl config current-context 2>/dev/null)"

    if [[ ! -z "$CONTEXT" ]]; then
        # Set colors based on the environment
        [[ "$CONTEXT" == *"production"*  ]] && COLOUR="$fg[red]"
        [[ "$CONTEXT" == *"staging"*     ]] && COLOUR="$fg[yellow]"
        [[ "$CONTEXT" == *"integration"* ]] && COLOUR="$fg[yellow]"
        [[ "$CONTEXT" == *"engineering"* ]] && COLOUR="$fg[green]"
        zsh_kubectl_info_msg="%{$COLOUR%}${CONTEXT}%{$reset_color%} "
    fi
}

function zsh_precmd_title() {
    case "$TERM" in
        xterm*) print -Pn "\e]2;%~\a";;
    esac
}

function zsh_preexec_title() {
    case "$TERM" in
        xterm*) print -Pn "\e]2;%~ $ $2\a";;
    esac
}

precmd_functions=(zsh_precmd_title vcs_info)
preexec_functions=(zsh_preexec_title)

# Assemble the prompt
#
#   $ sam@hostname ~
#   $ ...
#   $ sam@hostname ~/directory master production
#   $ ...
#
# The %{ and %} characters are used to stop the prompt from counting invisible
# characters when calculating the length
PROMPT="%{$prompt_fg%}$ %n@%m %{$prompt_highlight_fg%}%~%{$reset_color%} \
\${vcs_info_msg_0_}\
\${zsh_python_info_msg}\
\${zsh_kubectl_info_msg}\

%{$prompt_fg%}$%{$reset_color%} "

#
# Aliases
#

# Color basic commands.
alias ls='ls --color=auto'
alias grep='grep --color=auto'

# ls helpers
alias ll='ls -l'
alias la='ls -la'

# Short git helpers.
alias gd='git diff'
alias gs='git status'
alias gc='git commit'
alias gca='git commit -a'
alias cola='git-cola &'
alias gg='gitg &'

# Specific ansible tasks.
alias reconfigure-ssh='reconfigure -t ssh --force-handlers'
alias reconfigure-zshrc='reconfigure -t zshrc; source ~/.zshrc'

# Miscellaneous aliases.
alias httpie='http'
alias k='kubectl'
alias kube='kubectl'

#
# Named directories
#

export dev="$HOME/Development"
export dep="$HOME/Deployment"

export github="${dev}/github.com"
export gitlab="${dev}/gitlab.com"

export borntyping="${github}/borntyping"
export sandbox="${github}/borntyping-sandbox"

#
# Environment variables
#

export EDITOR="micro"
export GIT_PATH="${dev}" # git-get
export GOPATH="$HOME/.local/lib/go"
export LS_COLORS="rs=0:di=01;33:ln=target:or=41:ex=32"
export NPM_CONFIG_PREFIX="$HOME/.npm"
export PIPENV_IGNORE_VIRTUALENVS=1
export PIPENV_MAX_DEPTH=5
export SSH_RUN_SUDO_KEYRING=1
export VIRTUAL_ENV_DISABLE_PROMPT=1

#
# $PATH
#

function add_to_path() {
  if [[ -d $1 ]] && echo $PATH | grep -v $1 >/dev/null; then
    export PATH="$1:$PATH"
  fi
}

function source_if_path {
  if [[ -f $1 ]]; then
    source $1
  fi
}

add_to_path "${HOME}/.cargo/bin"
add_to_path "${HOME}/.gem/ruby/2.5.0/bin"
add_to_path "${HOME}/.go/bin"
add_to_path "${HOME}/.npm/bin"

add_to_path "${HOME}/.local/bin"
add_to_path "${HOME}/.bin"

#
# ZSH history search plugin.
# https://github.com/jimeh/zsh-peco-history
#

source_if_path "$HOME/.local/share/zsh/plugins/peco-history/zsh-peco-history.zsh"
ZSH_PECO_HISTORY_DEDUP=1

#
# Tilix VTE patch
# https://github.com/gnunn1/tilix/wiki/VTE-Configuration-Issue
#
source_if_path "/etc/profile.d/vte-2.91.sh"

#
# z - jump around
# https://github.com/rupa/z
#

source_if_path "$HOME/.local/share/zsh/plugins/z/z.sh"

#
# direnv - directory specific environment configuration
# https://direnv.net/
#

eval "$(direnv hook zsh)"

# We configure our precmd_functions that depend on environment variables after
# direnv so that environment variables set by direnv are available.
precmd_functions+=zsh_kubectl_info;
precmd_functions+=zsh_python_info;

#
# Kubernetes completion
# https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion
#

source <(kubectl completion zsh)
source <(minikube completion zsh)

#
# Local zsh config
#
source_if_path "$HOME/.config/zsh/zshrc"

#
# Kubernetes helpers
#

function ky() {
    kubectl -o yaml "$@" | bat --language yaml
}
function kq() {
    kubectl -o json "$@" | jq .
}

compdef k="kubectl"
compdef kq="kubectl"
compdef kube="kubectl"
compdef ky="kubectl"
