#!/usr/bin/env python3.10

import dataclasses
import os
import pathlib
import subprocess
import sys
import typing


def print_alert(text: str, *, fg: int, symbol: str, width: int = 100) -> None:
    if sys.stdout.isatty():
        text = f"%(start)s {symbol} {text:{width-4}} %(end)s"
        text = text % {
            "b": "\033[1m",  # bold
            "n": "\033[22m",  # normal
            "start": "\033[0;47;{}m".format(fg),
            "end": "\033[0m",
        }
    else:
        text = f"{symbol} {text}"
        text = text % {"b": "", "n": ""}

    print(text)


def print_start(text: str) -> None:
    print_alert(text, fg=30, symbol="➔")


def print_failure(text: str) -> None:
    print_alert(text, fg=31, symbol="!")


def print_success(text: str) -> None:
    print_alert(text, fg=32, symbol="➔")


@dataclasses.dataclass()
class Hook:
    name: str

    def __str__(self) -> str:
        return self.name

    def __call__(self) -> bool:
        command = f"git config --type=bool hooks.{self.name} false"
        print_start(f"Running %(b)s{self}%(n)s. Run '{command}' to disable. ")

        error = self.run()
        if error:
            print_failure(f"Hook %(b)s{self}%(n)s failed: {error}.")

        return error == None

    @staticmethod
    def git_hook_enabled(name: str) -> bool | None:
        command = ("git", "config", "--get", "--type", "bool", f"hooks.{name}")
        result = subprocess.run(command, capture_output=True, encoding="utf-8")

        if result.returncode == 0 and result.stdout.strip() == "true":
            return True
        elif result.returncode == 0 and result.stdout.strip() == "false":
            return False
        elif result.returncode == 1:
            return None

        raise Exception(f"Unexpected result from 'git config' ({result}).")

    def enabled(self) -> bool:
        ...

    def run(self) -> typing.Optional[str]:
        ...


@dataclasses.dataclass()
class ExcludeHook(Hook):
    pattern: str

    def enabled(self) -> bool:
        return self.git_hook_enabled(self.name) is not False

    def run(self) -> typing.Optional[str]:
        """
        * 'git diff HEAD' to include staged and unstaged changes.
        * 'git diff --unified=0' so we don't look at unchanged lines.
        """
        result = subprocess.run(
            ("git", "diff", "HEAD", "--unified=0"),
            capture_output=True,
            encoding="utf-8",
            env={"PAGER": "cat"},
        )

        if result.returncode != 0:
            return None

        if self.pattern in result.stdout:
            return f"commit diff includes {self.pattern!r}"

        return None


@dataclasses.dataclass()
class CommandHook(Hook):
    command: typing.Sequence[str]
    files: typing.Sequence[str]

    def enabled(self) -> bool:
        enabled = self.git_hook_enabled(self.name)
        configured = all(pathlib.Path(filename).exists() for filename in self.files)
        return (enabled is True) or (enabled is None and configured)

    def run(self) -> typing.Optional[str]:
        try:
            subprocess.run(self.command, check=True, encoding="utf-8")
        except subprocess.CalledProcessError as error:
            return f"return code was {error.returncode}"
        except FileNotFoundError as error:
            return f"{error}"
        return None


hooks = [
    ExcludeHook("exclude", "!nocommit"),
    # Python
    CommandHook("black", [".venv/bin/black", "--check", "."], ["pyproject.toml"]),
    CommandHook("flake8", [".venv/bin/flake8", "."], [".flake8"]),
    CommandHook("mypy", [".venv/bin/mypy"], ["pyproject.toml"]),
    CommandHook("pytest", [".venv/bin/pytest"], ["pyproject.toml"]),
    CommandHook("tox", ["tox"], ["tox.ini"]),
    # PHP
    CommandHook("phpunit", ["vendor/bin/phpunit"], ["vendor/bin/phpunit"]),
    CommandHook("phpstan", ["vendor/bin/phpstan"], ["vendor/bin/phpstan"]),
    # Others
    CommandHook("mkdocs", ["mkdocs", "build", "--strict"], ["mkdocs.yml"]),
    CommandHook("pre-commit", ["pre-commit", "run", "-a"], [".pre-commit-config.yaml"]),
]

if __name__ == "__main__":
    results = [(hook, hook()) for hook in hooks if hook.enabled()]
    failed = [hook for hook, result in results if not result]

    if failed:
        print_failure(f"Failed to run %(b)s{len(failed)}%(n)s hooks.")
        raise SystemExit(1)

    print_success(f"Successfully ran %(b)s{len(results)}%(n)s pre-commit hooks.")
