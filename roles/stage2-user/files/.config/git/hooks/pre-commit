#!/usr/bin/env python3.10

import dataclasses
import pathlib
import subprocess
from sys import intern
import textwrap
import typing


def alert(text: str, *, fg: int, bg: int, symbol: str, width: int = 100) -> None:
    return f"\033[0;{bg};{fg}m {symbol} {text:{width}}\033[0m"


def bold(text: str) -> str:
    return f"\033[1m{text}\033[22m"


def start(text: str) -> str:
    return alert(text, bg=47, fg=38, symbol="➔")


def failure(text: str) -> str:
    return alert(text, bg=47, fg=31, symbol="!")


def success(text: str) -> str:
    return alert(text, bg=47, fg=32, symbol="➔")


@dataclasses.dataclass()
class Hook:
    name: str

    def __str__(self) -> str:
        return self.name

    def __call__(self) -> bool:
        command = f"git config --type=bool hooks.{self.name} false"
        print(start(f"Running {bold(self)}. Run '{command}' to disable. "))

        error = self.run()
        if error:
            print(failure(f"Hook {bold(self)} failed: {error}."))

        return error == None

    @staticmethod
    def git_hook_enabled(name: str) -> bool:
        command = ("git", "config", "--get", "--type", "bool", f"hooks.{name}")
        result = subprocess.run(command, capture_output=True, encoding="utf-8")

        if result.returncode == 0 and result.stdout.strip() == "true":
            return True
        elif result.returncode == 0 and result.stdout.strip() == "false":
            return False
        elif result.returncode == 1:
            return None

        raise Exception(f"Unexpected result from 'git config' ({result}).")

    def enabled(self) -> bool:
        ...

    def run(self) -> typing.Optional[str]:
        ...


@dataclasses.dataclass()
class ExcludeHook(Hook):
    pattern: str

    def enabled(self) -> bool:
        return self.git_hook_enabled(self.name)

    def run(self) -> typing.Optional[str]:
        command = ("git", "diff")
        result = subprocess.run(command, capture_output=True, encoding="utf-8", env={})

        if result.returncode != 0:
            return None

        if self.pattern in result.stdout:
            return f"commit diff includes {self.pattern!r}"

        return None


@dataclasses.dataclass()
class CommandHook(Hook):
    command: typing.Sequence[str]
    files: typing.Sequence[str]

    def enabled(self) -> bool:
        enabled = self.git_hook_enabled(self.name)
        configured = all(pathlib.Path(filename).exists() for filename in self.files)
        return (enabled is True) or (enabled is None and configured)

    def run(self) -> typing.Optional[str]:
        result = subprocess.run(self.command, encoding="utf-8")
        if result.returncode != 0:
            return f"return code was {result.returncode}"


hooks = [
    ExcludeHook("exclude", "!nocommit"),
    # Python
    CommandHook("black", ["python", "-m", "black", "--check", "."], ["pyproject.toml"]),
    CommandHook("mypy", ["python", "-m", "mypy", "."], ["pyproject.toml"]),
    CommandHook("pytest", ["python", "-m", "pytest"], ["pyproject.toml"]),
    CommandHook("tox", ["tox"], ["tox.ini"]),
    # PHP
    CommandHook("phpunit", ["vendor/bin/phpunit"], ["vendor/bin/phpunit"]),
    CommandHook("phpstan", ["vendor/bin/phpstan"], ["vendor/bin/phpstan"]),
    # Others
    CommandHook("mkdocs", ["mkdocs", "build", "--strict"], ["mkdocs.yml"]),
    CommandHook("pre-commit", ["pre-commit", "run", "-a"], [".pre-commit-config.yaml"]),
]

if __name__ == "__main__":
    results = [(hook, hook()) for hook in hooks if hook.enabled()]
    failed = [hook for hook, result in results if not result]

    if failed:
        print(failure(f"Failed to run {bold(len(failed))} hooks."))
        raise SystemExit(1)

    print(success(f"Successfully ran {bold(len(results))} pre-commit hooks."))
